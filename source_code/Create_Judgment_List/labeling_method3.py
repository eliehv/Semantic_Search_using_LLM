# -*- coding: utf-8 -*-
"""Labeling-Method3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZdniLYuHGCf5tj1eMrtw_IiuErJZSOCj
"""

###################################################################################################################
####   creating Judgment list with Method 1
#----- candidates generated by “msmarco-distilbert-dot-v5” will be re-ranked by Cross-Encoder and BERTScore
#----- intersection of re-ranked lists will be the final set of relevant items (Judgment list)
###################################################################################################################
num_labels = 30 #Method 1 parameter ---- 30 is the suitable value based on experiments in this research
for q in range(len(query_info_msmarco)):
  df_tmp = query_info_msmarco[q]['top_k']['CrossEncoder_results']
  bdf_tmp = query_info_msmarco[q]['top_k']['BertScore_results']
  crossEncode_tops = []
  bertScore_tops = []
  for index,row in df_tmp.iterrows():
    crossEncode_tops.append(row['title'])
  for bindex,brow in bdf_tmp.iterrows():
    bertScore_tops.append(brow['title'])

  labels = list(set(bertScore_tops).intersection(crossEncode_tops))


  if len(labels) == 0 :
    labels = list(set(bertScore_tops[:(int(num_labels/2))]).union(set(crossEncode_tops[:(int(num_labels/2))])))

  query_info_msmarco[q]['labels'] = labels
  print('common titles : ',labels)

  crossEncode_idx_tops = []
  bertScore_idx_tops= []
  for index,row in df_tmp.iterrows():
    crossEncode_idx_tops.append(row['index'])

  for bindex,brow in bdf_tmp.iterrows():
    bertScore_idx_tops.append(brow['index'])

  labels_idx = list(set(bertScore_idx_tops).intersection(crossEncode_idx_tops))
  if len(labels_idx) == 0 :
    labels_idx = list(set(bertScore_idx_tops[:(int(num_labels/2))]).union(set(crossEncode_idx_tops[:(int(num_labels/2))])))
  query_info_msmarco[q]['labels_idx'] = labels_idx

###################################################################################################################
#### creating Judgment list with Method 2
#----- candidates generated by “gpt2-large” will be re-ranked by Cross-Encoder and BERTScore
#----- for similarity scores of chunks and queries calculated by both Cross-Encoder and BERTScore :
#   ----- all chunks of all candidates' Plots form a sigle set and the highest-scored will be selected
#   ----- selected chunks will be grouped by the movies and the groupd (movies) with most members are chosen as relevant
#----- intersection of re-ranked lists will be the final set of relevant items (Judgment list)
###################################################################################################################
k = 5 #Method 2 parameter to reach a reasonable number of items in group to be qualified
for q in range(len(query_info)):
  ###          Cross-Encoder
  final_score = []
  final_index = []
  final_chunks = []
  final_title = []
  final_genre = []
  for i in range(len(query_info[q]["top_k"]["CrossEncoder"])):
    for s in query_info[q]['top_k']['CrossEncoder'][i]:
      final_score.append(s)
    for c in query_info[q]['top_k']['chunks'][i]:
      final_chunks.append(c)
      final_title.append(df_new.iloc[int(query_info[q]['top_k']['score_idx'][1][i])]['Title'])
      final_genre.append(df_new.iloc[int(query_info[q]['top_k']['score_idx'][1][i])]['Clean_Genre'])
      final_index.append(query_info[q]['top_k']['score_idx'][1][i].item())
  data = ({'score':final_score,
          'chunk':final_chunks,
            'title':final_title,
            'genre':final_genre,
            'index':final_index})
  df_tmp = pd.DataFrame(data)
  df_tmp.sort_values('score', ascending = True, inplace = True)
  df_tmp_group = df_tmp.groupby("index", sort = True)
  l =[]
  for v in df_tmp_group.groups.values():
    l.append(len(v))
  tmp = df_tmp_group.filter(lambda x: x['index'].count()> (max(l)-k))['index'].reset_index().groupby("index", sort = True)
  crossEncode_tops = list(tmp.groups.keys())
  # get the title of items as the crossEncode_tops only contains indeces of the items
  crossEncode_tops_titles = []
  for item_idx in crossEncode_tops:
    crossEncode_tops_titles.append(df_tmp[df_tmp['index'] == item_idx]['title'].values[0])
  ##################################################
  ###           BERTScore
  final_bscore = []
  final_bindex = []
  final_bchunks = []
  final_btitle = []
  final_bgenre = []

  for i in range(len(query_info[q]["top_k"]["BertScore_F1"])):
    for s in query_info[q]['top_k']['BertScore_F1'][i]:
      final_bscore.append(s)
    for c in query_info[q]['top_k']['chunks'][i]:
      final_bchunks.append(c)
      final_btitle.append(df_new.iloc[int(query_info[q]['top_k']['score_idx'][1][i])]['Title'])
      final_bgenre.append(df_new.iloc[int(query_info[q]['top_k']['score_idx'][1][i])]['Clean_Genre'])
      final_bindex.append(query_info[q]['top_k']['score_idx'][1][i].item())
  bdata = ({'score':final_bscore,
          'chunk':final_bchunks,
            'title':final_btitle,
            'genre':final_bgenre,
            'index':final_bindex})
  bdf_tmp = pd.DataFrame(bdata)
  bdf_tmp.sort_values('score', ascending = False, inplace = True)
  bdf_tmp = bdf_tmp[(bdf_tmp['score'] > -1) & (bdf_tmp['score'] < 1) ]
  bdf_tmp_group = bdf_tmp.groupby("index", sort = True)

  bl =[]
  for bv in bdf_tmp_group.groups.values():
    bl.append(len(bv))
  btmp = bdf_tmp_group.filter(lambda x: x['index'].count()> (max(bl)-k))['index'].reset_index().groupby("index", sort = True)
  bertScore_tops = list(btmp.groups.keys())
  bertScore_tops_titles = []
  for bitem_idx in bertScore_tops:
    bertScore_tops_titles.append(bdf_tmp[bdf_tmp['index'] == bitem_idx]['title'].values[0])

  labels_idx = list(set(bertScore_tops).intersection(set(crossEncode_tops)))
  labels = list(set(bertScore_tops_titles).intersection(set(crossEncode_tops_titles)))
  query_info[q]['labels'] = labels
  query_info[q]['labels_idx'] = labels_idx

############################################################################
  ###           The Union of the labels created with Method 1 and Method 2
  ############################################################################
for q in range(len(query_info)):
  print('query: ', query_info[q]['query'])
  print('relevant items from gpt2:', query_info[q]['labels'])
  print('relevant items from msmarco: ', query_info_msmarco[q]['labels'])
  print('common relevant items: ',list(set(query_info[q]['labels']).intersection(set(query_info_msmarco[q]['labels']))))
  #*************** Union of GPT2 and DistilBERT relevant lists ************************
  print('union  of relevant items: ',list(set(query_info[q]['labels']).union(set(query_info_msmarco[q]['labels']))))
  relevant_list = list(set(query_info[q]['labels_idx']).union(set(query_info_msmarco[q]['labels_idx'])))
  print('*************************\n\n')